```clojure\n(ns excalidraw.app.alpha.v05\n (:require \n [clojure.set :as s]\n [reagent.core :as r]\n [roam.datascript :as rd]\n [roam.block :as block]\n [clojure.string :as str]\n [clojure.edn :as edn]\n [roam.util :as util]\n [roam.datascript.reactive :as dr]))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Common functions\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(def silent false)\n(defn debug [x]\n (if-not silent (apply (.-log js/console) x)))\n\n(defn js-to-clj-str [& x]\n (debug [\"(js-to-clj-str): x: \" x (str x)])\n (let [res (-> x\n (str)\n (str/replace #\"\\(#js\" \"\")\n (str/replace #\"#js\" \"\")\n (str/replace #\"\\}\\}\\)\" \"}}\"))]\n (debug [\"(js-to-clj-str) result: \" res])\n res))\n\n(defn fix-double-bracket [x]\n (str/replace x #\"\\[{2}\" \"[ [\"))\n\n(defn save-component [block-uid map-string]\n (debug [\"(save-component) Enter\"])\n (let [drawing-block-uid (rd/q '[:find ?drawing-uid .\n :in $ ?uid\n :where [?e :block/uid ?uid]\n [?e :block/children ?c]\n [?c :block/order 0]\n [?c :block/string ?s]\n [(clojure.string/starts-with? ?s \"{{roam/render: ((ExcalDATA)) \")]\n [?c :block/uid ?drawing-uid]]\n block-uid)\n render-string (str/join [\"{{roam/render: ((ExcalDATA)) \" (fix-double-bracket map-string) \" }}\"])]\n (debug [\"(save-component) data-string: \" render-string])\n (block/update\n {:block {:uid drawing-block-uid\n :string render-string}})))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Load data from nested block(s)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defn create-block [parent-uid order block-string]\n (.createBlock js/window.ExcalidrawWrapper parent-uid order block-string))\n\n;;finds the json enclosed in double parentheses and returns it\n(defn get-data-from-block-string [x]\n (debug [\"(get-data-from-block-string)\" (count x)])\n (if (= (count x) 0)\n (do \n (debug [\"(get-data-from-block-string) returning nil\"])\n nil)\n (do\n (let [data-string (get-in (first x) [0 :block/string])]\n (debug [\"(get-data-from-block-string) returning: \" (second (re-find #\"ExcalDATA\\){2}\\s*(\\{.*\\})\\s*\\}{2}\" data-string))])\n (edn/read-string (second (re-find #\"ExcalDATA\\){2}\\s*(\\{.*\\})\\s*\\}{2}\" data-string)))))))\n\n(defn load-drawing [block-uid drawing data text] ;drawing is the atom holding the drawing map\n (debug [\"(load-drawing) enter\"])\n (if (nil? data)\n (do\n (debug [\"(load-drawing) create ExcalDATA & title\"])\n (create-block block-uid 0 \"{{roam/render: ((ExcalDATA)) {} }}\")\n (reset! drawing {:drawing \n {:appState {:name \"Untitled drawing\"}} \n :title {:text \"Untitled drawing\"\n :block-uid (create-block block-uid 1 \"Untitled drawing\")}}));\n (if (= (count text) 0)\n (do\n (debug [\"(load-drawing) create title only\"])\n (reset! drawing {:drawing data\n :title {:text \"Untitled drawing\"\n :block-uid (create-block block-uid 1 \"Untitled drawing\")}}))\n (do\n (debug [\"(load-drawing) ExcalDATA & title already exist\"])\n (reset! drawing {:drawing data\n :title {:text (get-in text [0 :block/string])\n :block-uid (get-in text [0 :block/uid])}}))))\n (debug [\"(load-drawing) drawing: \" @drawing \" data: \" data \" text: \" (str text) \"appearance \" (get-in data [:appState :appearance])]));)\n\n\n(defn generate-scene [drawing]\n (let [scene (:drawing @drawing)]\n (debug [\"(generate-scene)\"])\n ;(debug [\"(generate-scene) drawing: \" (str @drawing)])\n ;(debug [\"(generate-scene) scene: \" (str scene) \" count scene: \" (count scene) \" is nil? \" (nil? scene)])\n ;(debug [\"(generate-scene) appState: \" (str (get-in scene [:appState]))])\n ;(debug [\"(generate-scene) scene: \" (str (assoc-in scene [:appState :name] (:title @drawing)))]) ;))])\n (assoc-in scene [:appState :name] (get-in @drawing [:title :text]))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Main Function Form-3\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(def embedded-view \"ev\")\n(def full-screen-view \"fs\")\n(def embed-width 500)\n\n(defn is-full-screen [cs] ;;component-state\n (not= (:position @cs) embedded-view))\n\n(defn set-zen-mode-enabled [ew cs value] ;;exalidraw-wrapper component-state\n (debug [\"(set-zen-mode-enabled) \" value])\n (swap! cs assoc-in [:zen-mode] value)\n (if-not (nil? @ew) (.setZenModeEnabled @ew value)))\n\n(defn set-grid-mode-enabled [ew cs value] ;;exalidraw-wrapper component-state\n (debug [\"(set-grid-mode-enabled) \" value])\n (swap! cs assoc-in [:grid-mode] value)\n (if-not (nil? @ew) (.setGridModeEnabled @ew value)))\n\n(defn resize [ew]\n (debug [\"(resize)\"])\n (if-not (nil? @ew) (.onResize @ew)))\n\n(defn zoom-to-fit [ew]\n (debug [\"(zoom-to-fit)\"])\n (if-not (nil? @ew) (.zoomToFit @ew)))\n\n(defn update-scene [ew scene]\n (debug [\"(update-scene) scene: \" scene])\n (if-not (nil? @ew) (.updateScene @ew scene)))\n ;(.updateScene js/window.ExcalidrawWrapper @ew scene))\n\n(defn get-drawing [ew]\n (debug [\"(get-drawing): \" (.getDrawing js/window.ExcalidrawWrapper @ew)])\n (.getDrawing js/window.ExcalidrawWrapper @ew))\n\n(defn going-full-screen? [x]\n (if (= x true)\n (.fullScreenKeyboardEventRedirect js/window.ExcalidrawWrapper true)\n (.fullScreenKeyboardEventRedirect js/window.ExcalidrawWrapper false)))\n\n(defn host-div-style [cs]\n (let [width (.-innerWidth js/window)\n height (.-innerHeight js/window)]\n (debug [\"(host-div-style) cur-state :position \" (:position @cs) \" :height \" height \" :width \" width \" full-screen? \" (is-full-screen cs)])\n (if (is-full-screen cs)\n {:position \"fixed\"\n :z-index 1000\n :top 50\n :left 50\n :width \"calc(100% - 100px)\" ;;(- width 100) ;;\n :height (- height 100)\n :background \"white\"}\n {:position \"relative\"\n :width embed-width\n :height \"100%\"\n :display \"block\"\n :resize \"both\"\n ; :background (if (= (:appearance @cs) \"dark\") \"black\" \"white\")\n :overflow \"hidden\"})))\n\n;;state to capture when callback confirms React libraries have loaded\n(def deps-available (r/atom false))\n\n(defn check-js-dependencies []\n (if (and (not= (str (type js/ExcalidrawUtils)) \"\")\n (not= (str (type js/Excalidraw)) \"\")\n (not= (str (type js/ReactDOM)) \"\")\n (not= (str (type js/React)) \"\"))\n (reset! deps-available true)\n (js/setTimeout check-js-dependencies 1000)\n ))\n\n(defn pull-children [block-uid order]\n (rd/q '[:find (pull ?b [:block/uid :block/string {:block/children [:block/string :block/order :block/uid {:block/children ...}]}])\n :in $ ?block-uid ?order\n :where [?e :block/uid ?block-uid]\n [?e :block/children ?b]\n [?b :block/order ?order]]\n\t\t\t block-uid order))\n\n(defn main [{:keys [block-uid]} & args]\n (debug [\"(main) component starting...\"])\n (check-js-dependencies)\n (if (= @deps-available false)\n [:div \"Libraries have not yet loaded. Please refresh the block in a moment.\"]\n (fn []\n (debug [\"(main) fn[] starting...\"])\n (let [drawing (r/atom nil)\n cs (r/atom {:position embedded-view ;;component-state\n :view-mode false\n :zen-mode false\n :grid-mode false})\n ew (r/atom nil) ;;excalidraw-wrapper\n drawing-before-edit (r/atom nil)\n app-name (str/join [\"excalidraw-app-\" block-uid])\n this-dom-node (r/atom nil)\n pull-watch-callback (fn [before after]\n (let [drawing-data (pull-children block-uid 0)\n drawing-text (pull-children block-uid 1)]\n (load-drawing block-uid drawing (get-data-from-block-string drawing-data) (first drawing-text) )\n ; (if (is-full-screen cs) (update-scene ew (generate-scene drawing)))\n (debug [\"(main) :callback drawing-data appearance\" (get-in @drawing [:drawing :appState :appearance]) ]) ))]\n (r/create-class\n { :display-name \"Excalidraw Roam Beta\"\n ;; Constructor\n; :constructor (fn [this props]\n; (debug [\"(main) :constructor\"]))\n; :get-initial-state (fn [this]\n; (debug [\"(main) :get-initial-state\"]))\n ;; Static methods\n; :get-derived-state-from-props (fn [props state] )\n; :get-derived-state-from-error (fn [error] )\n ;; Methods\n ; :get-snapshot-before-update (fn [this old-argv new-argv] )\n ; :should-component-update (fn [this old-argv new-argv]\n ; (debug [\"(main) :should-component-update\"]))\n :component-did-mount (fn [this]\n (debug [\"(main) :component-did-mount\"])\n (reset! this-dom-node (r/dom-node this))\n (.addPullWatch js/ExcalidrawWrapper block-uid pull-watch-callback)\n (pull-watch-callback nil nil)\n (.getPNG js/window.ExcalidrawWrapper (generate-scene drawing) @this-dom-node app-name)\n (debug [\"(main) :component-did-mount Exalidraw mount initiated\"]))\n :component-did-update (fn [this old-argv old-state snapshot]\n (debug [\"(main) :component-did-update\"])\n (if (is-full-screen cs)\n (resize ew)))\n :component-will-unmount (fn [this]\n (.removePullWatch js/ExcalidrawWrapper block-uid pull-watch-callback))\n; :component-did-catch (fn [this error info])\n :reagent-render (fn [{:keys [block-uid]} & args]\n (debug [\"(main) :reagent-render\"])\n [:div.excalidraw-host\n {:style (host-div-style cs 50)}\n [:div.ex-header-wrapper\n [:span.ex-header-buttons-wrapper\n [:button.ex-header-button\n {:draggable true\n :on-click (fn [e]\n (if (is-full-screen cs)\n (do (save-component block-uid (js-to-clj-str (get-drawing ew)))\n (going-full-screen? false)\n ;(pull-watch-callback nil nil)\n ;(load-drawing block-uid drawing drawing-data drawing-text)\n (.getPNG js/window.ExcalidrawWrapper (get-drawing ew) @this-dom-node app-name)) ;(generate-scene drawing)\n (do (going-full-screen? true)\n (reset! drawing-before-edit (generate-scene drawing))\n (debug [\"(main) :on-click drawing-before-edig \" @drawing-before-edit])\n (reset! ew (js/ExcalidrawWrapper.\n app-name\n @drawing-before-edit\n @this-dom-node))))\n (swap! cs assoc-in [:position]\n (if (is-full-screen cs) embedded-view full-screen-view)))}\n (if (is-full-screen cs) \"Save\" \"Edit\")]\n (if (is-full-screen cs)\n [:button.ex-header-button\n {:draggable true\n :on-click (fn [e]\n (going-full-screen? false)\n (debug [\"(main) Cancel :on-click\"])\n (save-component block-uid (str @drawing-before-edit))\n (.getPNG js/window.ExcalidrawWrapper @drawing-before-edit @this-dom-node app-name)\n (swap!\n cs\n assoc-in [:position] embedded-view))}\n \"Cancel\"])]\n [:span.ex-header-title-wrapper\n [:input.ex-header-title\n {:value (get-in @drawing [:title :text])\n :on-change (fn [e] \n (swap! drawing assoc-in [:title :text] (.. e -target -value))\n (block/update\n {:block {:uid (get-in @drawing [:title :block-uid])\n :string (get-in @drawing [:title :text])}})\n (if (is-full-screen cs)\n (do\n (let [x (edn/read-string\n (js-to-clj-str\n (get-drawing ew)))]\n (debug [\"(main) input.ex-header-title update x:\" x])\n (update-scene \n ew \n (assoc-in \n x \n [:appState :name] (get-in @drawing [:title :text]))))))\n )}]]\n (if (is-full-screen cs)\n [:span.ex-header-options-wrapper\n [:label.ex-header-options-label [:input.ex-header-options-checkbox\n {:type \"checkbox\"\n :checked (:zen-mode @cs)\n :on-change (fn [e]\n (set-zen-mode-enabled\n ew\n cs\n (not (:zen-mode @cs))))}]\n \"Zen Mode\"]\n [:label.ex-header-options-label [:input.ex-header-options-checkbox\n {:type \"checkbox\"\n :checked (:grid-mode @cs)\n :on-change (fn [e]\n (set-grid-mode-enabled\n ew\n cs\n (not (:grid-mode @cs))))}]\n \"Grid Mode\"]])];];)]\n [:div\n {:id app-name\n :style (if (is-full-screen cs)\n {:position \"relative\" :width \"100%\" :height \"calc(100% - 30px)\"}\n {:background (if (= (get-in @drawing [:drawing :appState :appearance]) \"dark\") \"black\" \"white\")})}\n ]])})))))```